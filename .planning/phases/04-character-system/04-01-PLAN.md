---
phase: 04-character-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/character.ts
  - src/reducers/characterReducer.ts
  - src/hooks/useCharacter.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "Character has four stats (Acuity, Body, Heart, Will) each with dice arrays"
    - "Character has traits, inventory items, and relationships as typed collections"
    - "Character state can be created, modified, and queried through a reducer"
    - "Character creation produces a valid Dog with point-buy allocated stats and starting inventory"
  artifacts:
    - path: "src/types/character.ts"
      provides: "Character, Stat, Trait, Item, Relationship, DiceSource types"
      exports: ["Character", "Stat", "Trait", "Item", "Relationship", "DiceSource", "Background", "CharacterAction"]
    - path: "src/reducers/characterReducer.ts"
      provides: "Immer-wrapped character state reducer"
      exports: ["characterReducer", "initialCharacterState"]
    - path: "src/hooks/useCharacter.tsx"
      provides: "CharacterProvider context and useCharacter hook"
      exports: ["CharacterProvider", "useCharacter"]
  key_links:
    - from: "src/types/character.ts"
      to: "src/types/game.ts"
      via: "imports DieType, Die"
      pattern: "import.*DieType.*from.*game"
    - from: "src/reducers/characterReducer.ts"
      to: "src/types/character.ts"
      via: "imports all character types"
      pattern: "import.*Character.*from.*character"
    - from: "src/hooks/useCharacter.tsx"
      to: "src/reducers/characterReducer.ts"
      via: "useReducer with characterReducer"
      pattern: "useReducer\\(characterReducer"
---

<objective>
Create the character type system, state reducer, and context provider for the Dog's stats, traits, inventory, and relationships.

Purpose: This is the data foundation for all character system features. Stats provide dice to conflict pools, traits can be invoked mid-conflict, items contribute dice, and relationships affect relevant conflicts. Everything else in Phase 4 depends on these types and state management.

Output: Character types, Immer-based reducer, and React context provider wrapping the app.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-character-system/04-CONTEXT.md
@.planning/phases/04-character-system/04-RESEARCH.md
@src/types/game.ts
@src/types/conflict.ts
@src/hooks/useGameState.tsx
@src/utils/dice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create character types</name>
  <files>package.json, src/types/character.ts</files>
  <action>
    Install immer and lucide-react:
    ```
    npm install immer lucide-react
    ```

    Create `src/types/character.ts` with DitV-faithful character types:

    1. Import `DieType` from `@/types/game` (reuse existing die type union)

    2. Define `CharacterDie` interface (simpler than game Die - no assignedTo needed):
       - id: string
       - type: DieType

    3. Define `Stat` interface:
       - name: 'acuity' | 'body' | 'heart' | 'will'
       - dice: CharacterDie[] (e.g., [d6, d6, d6] for 3d6 in that stat)
       - modifier: number (temporary reduction from injuries, starts at 0)

    4. Define `Trait` interface:
       - id: string
       - name: string (e.g., "I'm a Dog", "Quick draw")
       - dice: CharacterDie[] (e.g., [d6, d4])
       - source: 'creation' | 'fallout' (tracks origin)
       - description?: string

    5. Define `ItemCategory` type: 'normal' | 'big' | 'excellent' | 'big-excellent' | 'crap'

    6. Define `Item` interface:
       - id: string
       - name: string
       - category: ItemCategory
       - dice: CharacterDie[] (determined by category)
       - isGun: boolean

    7. Define `Relationship` interface:
       - id: string
       - npcId: string
       - npcName: string
       - dice: CharacterDie[]
       - description?: string

    8. Define `DiceSource` discriminated union (source field as discriminator):
       - { source: 'stat'; statName: Stat['name']; dice: CharacterDie[] }
       - { source: 'trait'; traitId: string; traitName: string; dice: CharacterDie[] }
       - { source: 'item'; itemId: string; itemName: string; dice: CharacterDie[] }
       - { source: 'relationship'; npcId: string; npcName: string; dice: CharacterDie[] }

    9. Define `Background` type: 'complicated-history' | 'strong-community' | 'well-rounded'

    10. Define `BACKGROUND_DICE` constant mapping each Background to:
        - statDice: number (how many d6 to distribute: 13, 15, 17 respectively)
        - traitDice: CharacterDie[] (varies by background per DitV rules)
        - relationshipDice: CharacterDie[] (varies by background)

    11. Define `Character` interface:
        - id: string
        - name: string
        - background: Background
        - stats: { acuity: Stat; body: Stat; heart: Stat; will: Stat }
        - traits: Trait[]
        - inventory: Item[]
        - relationships: Relationship[]

    12. Define `CharacterAction` discriminated union:
        - { type: 'SET_CHARACTER'; character: Character }
        - { type: 'ADD_TRAIT'; trait: Trait }
        - { type: 'REMOVE_TRAIT'; traitId: string }
        - { type: 'UPDATE_STAT_MODIFIER'; statName: Stat['name']; modifier: number }
        - { type: 'ADD_ITEM'; item: Item }
        - { type: 'REMOVE_ITEM'; itemId: string }
        - { type: 'ADD_RELATIONSHIP'; relationship: Relationship }
        - { type: 'UPDATE_RELATIONSHIP_DICE'; relationshipId: string; dice: CharacterDie[] }

    13. Export helper function `createStartingInventory(): Item[]` that returns:
        - Coat: category 'big', dice [d8], isGun false
        - Gun: category 'normal', dice [d6, d4], isGun true
        - Book of Life: category 'normal', dice [d6], isGun false
        - Sacred Earth (jar): category 'normal', dice [d6], isGun false
        Each with crypto.randomUUID() for id.

    14. Export helper function `createCharacter(name, background, statAllocation)`:
        - statAllocation is { acuity: number; body: number; heart: number; will: number }
        - Validates total equals BACKGROUND_DICE[background].statDice, throws if not
        - Creates stats with allocated d6 dice arrays
        - Includes starting inventory from createStartingInventory()
        - Returns complete Character object

    Use the existing DieType from game.ts ('d4' | 'd6' | 'd8' | 'd10') - do NOT redefine it.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit` passes with no character type errors</verify>
  <done>Character types defined with all interfaces, Background constants, createCharacter and createStartingInventory helpers exported</done>
</task>

<task type="auto">
  <name>Task 2: Create character reducer and context provider</name>
  <files>src/reducers/characterReducer.ts, src/hooks/useCharacter.tsx, src/App.tsx</files>
  <action>
    Create `src/reducers/characterReducer.ts`:
    - Import `produce` from 'immer'
    - Import Character, CharacterAction from '@/types/character'
    - Export `initialCharacterState: Character | null` as null (no character until creation)
    - Export `characterReducer` wrapped in produce():
      - SET_CHARACTER: replace entire state with action.character
      - ADD_TRAIT: push trait to draft.traits
      - REMOVE_TRAIT: filter out trait by id
      - UPDATE_STAT_MODIFIER: set draft.stats[statName].modifier = action.modifier
      - ADD_ITEM: push item to draft.inventory
      - REMOVE_ITEM: filter out item by id
      - ADD_RELATIONSHIP: push relationship to draft.relationships
      - UPDATE_RELATIONSHIP_DICE: find relationship by id, update dice array
    - Handle null state: if draft is null and action is not SET_CHARACTER, return null
    - Use Immer's produce for clean mutable-style updates on the draft

    Create `src/hooks/useCharacter.tsx`:
    - Import createContext, useContext, useReducer, ReactNode, Dispatch
    - Import characterReducer, initialCharacterState from '@/reducers/characterReducer'
    - Import Character, CharacterAction from '@/types/character'
    - Create CharacterContext with value type { character: Character | null; dispatch: Dispatch<CharacterAction> } | null
    - Export CharacterProvider component:
      - Uses useReducer(characterReducer, initialCharacterState)
      - Wraps children in CharacterContext.Provider
    - Export useCharacter() hook:
      - Gets context, throws if null (must be within CharacterProvider)
      - Returns { character, dispatch }

    Update `src/App.tsx`:
    - Import CharacterProvider from '@/hooks/useCharacter'
    - Wrap existing component tree: CharacterProvider should wrap around GameProvider and NPCMemoryProvider (outermost provider since character is the most fundamental entity)
    - Maintain existing provider nesting order within CharacterProvider
  </action>
  <verify>`npm run build` succeeds. App loads without errors (providers initialized).</verify>
  <done>Character reducer handles all action types with Immer, CharacterProvider wraps the app, useCharacter hook available throughout component tree</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- App loads in browser without errors
- CharacterProvider, useCharacter are importable from '@/hooks/useCharacter'
- Character types are importable from '@/types/character'
- createCharacter('Test', 'well-rounded', {acuity:5, body:4, heart:4, will:4}) returns valid Character
</verification>

<success_criteria>
- Character type system complete with DitV-faithful stats, traits, items, relationships
- Immer reducer handles all character mutations
- Context provider wraps app and hook is available
- TypeScript compiles, app builds and loads
</success_criteria>

<output>
After completion, create `.planning/phases/04-character-system/04-01-SUMMARY.md`
</output>
