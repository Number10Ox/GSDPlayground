---
phase: 02-cycle-system
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/types/game.ts
  - src/hooks/useGameState.tsx
autonomous: true

must_haves:
  truths:
    - "Game tracks current cycle phase (WAKE, ALLOCATE, RESOLVE, SUMMARY, REST)"
    - "Phase transitions follow valid state machine rules"
    - "Cycle number increments when new cycle starts"
    - "Dice pool is generated at cycle start"
  artifacts:
    - path: "src/types/game.ts"
      provides: "GameAction union includes cycle actions"
      contains: "START_CYCLE.*SELECT_DIE.*ASSIGN_DIE.*CONFIRM_ALLOCATIONS"
    - path: "src/hooks/useGameState.tsx"
      provides: "Reducer handles cycle state transitions"
      min_lines: 80
  key_links:
    - from: "src/hooks/useGameState.tsx"
      to: "src/utils/dice.ts"
      via: "generateDicePool call"
      pattern: "generateDicePool"
    - from: "src/hooks/useGameState.tsx"
      to: "src/types/game.ts"
      via: "CyclePhase type usage"
      pattern: "CyclePhase"
---

<objective>
Implement the cycle state machine that governs the daily loop: wake, allocate dice, resolve actions, view summary, rest.

Purpose: This is the core game loop engine. The state machine ensures players can only perform valid actions for the current phase and provides the structure that makes dice allocation meaningful.
Output: Extended GameState and reducer with phase-aware action handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cycle-system/02-CONTEXT.md
@.planning/phases/02-cycle-system/02-RESEARCH.md

# Required from Plan 01
@src/types/game.ts
@src/utils/dice.ts
@src/hooks/useGameState.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GameState with cycle state</name>
  <files>src/types/game.ts</files>
  <action>
    Extend GameState interface to include cycle state (Plan 01 should have added Die, DieType, CyclePhase):

    ```typescript
    export interface GameState {
      // Existing Phase 1 state
      currentLocation: LocationId;
      isPanelOpen: boolean;
      currentScene: Scene | null;
      locations: Location[];

      // New cycle state
      cyclePhase: CyclePhase;
      cycleNumber: number;
      dicePool: Die[];
      selectedDieId: string | null;
      clocks: Clock[];
    }
    ```

    Add new action types to GameAction union:

    ```typescript
    export type GameAction =
      // Existing Phase 1 actions
      | { type: 'NAVIGATE'; locationId: LocationId }
      | { type: 'OPEN_PANEL'; scene: Scene }
      | { type: 'CLOSE_PANEL' }
      // New cycle actions
      | { type: 'START_CYCLE' }
      | { type: 'SELECT_DIE'; dieId: string }
      | { type: 'ASSIGN_DIE'; actionId: string }
      | { type: 'UNASSIGN_DIE'; dieId: string }
      | { type: 'CONFIRM_ALLOCATIONS' }
      | { type: 'RESOLVE_NEXT' }
      | { type: 'ADVANCE_CLOCK'; clockId: string; amount: number }
      | { type: 'VIEW_SUMMARY' }
      | { type: 'END_CYCLE' }
      | { type: 'REST_EARLY' };
    ```
  </action>
  <verify>TypeScript compiles: `npm run build` passes</verify>
  <done>GameState includes cycle fields, GameAction includes cycle actions</done>
</task>

<task type="auto">
  <name>Task 2: Implement cycle state machine in reducer</name>
  <files>src/hooks/useGameState.tsx</files>
  <action>
    Update gameReducer to handle cycle state with phase guards:

    1. Update initialState to include:
       - cyclePhase: 'WAKE'
       - cycleNumber: 1
       - dicePool: [] (empty until START_CYCLE)
       - selectedDieId: null
       - clocks: [] (sample clocks for testing)

    2. Add sample clocks for testing:
       ```typescript
       const SAMPLE_CLOCKS: Clock[] = [
         { id: 'murder-plot', label: 'Murder Plot', segments: 6, filled: 2, type: 'danger', autoAdvance: true },
         { id: 'trust-earned', label: 'Trust Earned', segments: 4, filled: 1, type: 'progress', autoAdvance: false },
       ];
       ```

    3. Implement action handlers with phase guards:

       START_CYCLE (valid in: WAKE, REST):
       - Generate dice pool using generateDicePool(100) for now (full health)
       - Set cyclePhase to 'ALLOCATE'
       - Clear selectedDieId

       SELECT_DIE (valid in: ALLOCATE):
       - If same die selected, deselect (toggle behavior)
       - Otherwise set selectedDieId
       - Only allow selecting unassigned dice

       ASSIGN_DIE (valid in: ALLOCATE):
       - Requires selectedDieId to be set
       - Update the die's assignedTo field to the actionId
       - Clear selectedDieId after assignment

       UNASSIGN_DIE (valid in: ALLOCATE):
       - Find die by dieId, set assignedTo to null
       - If that die was selected, clear selection

       CONFIRM_ALLOCATIONS (valid in: ALLOCATE):
       - Transition to 'RESOLVE' phase
       - At least one die must be assigned (guard against empty confirm)

       RESOLVE_NEXT (valid in: RESOLVE):
       - For now, just transition to SUMMARY (actual resolution logic in Plan 04)

       VIEW_SUMMARY (valid in: RESOLVE):
       - Transition to 'SUMMARY' phase

       ADVANCE_CLOCK (valid in: any phase, typically called during RESOLVE):
       - Find clock by id, increment filled by amount
       - Cap at clock.segments maximum

       END_CYCLE (valid in: SUMMARY):
       - Increment cycleNumber
       - Advance autoAdvance clocks by 1
       - Transition to 'WAKE' phase
       - Clear dicePool

       REST_EARLY (valid in: ALLOCATE):
       - Skip to SUMMARY with remaining dice unused
       - Transition to 'SUMMARY' phase

    4. For invalid action/phase combinations, return state unchanged (no error, just ignore).
  </action>
  <verify>
    1. TypeScript compiles: `npm run build`
    2. Manual test: dispatch START_CYCLE, confirm dicePool populated and phase is ALLOCATE
  </verify>
  <done>Reducer handles all cycle actions with phase guards, state machine transitions work correctly</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. GameState includes: cyclePhase, cycleNumber, dicePool, selectedDieId, clocks
3. GameAction includes all cycle actions
4. START_CYCLE generates dice and transitions to ALLOCATE
5. SELECT_DIE/ASSIGN_DIE/UNASSIGN_DIE work during ALLOCATE
6. CONFIRM_ALLOCATIONS transitions to RESOLVE
7. END_CYCLE increments cycle number and advances autoAdvance clocks
8. Invalid phase/action combinations are silently ignored
</verification>

<success_criteria>
- Game state tracks which phase of the cycle player is in
- Only valid actions for current phase are processed
- Dice pool is generated when cycle starts
- Cycle number increments correctly
- Auto-advance clocks tick at end of cycle
</success_criteria>

<output>
After completion, create `.planning/phases/02-cycle-system/02-03-SUMMARY.md`
</output>
