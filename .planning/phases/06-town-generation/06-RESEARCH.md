# Phase 6: Town Generation - Research

**Researched:** 2026-01-22
**Domain:** Procedural narrative generation for Dogs in the Vineyard sin progression system
**Confidence:** MEDIUM

## Summary

Town generation for this DitV-inspired game requires template-based procedural generation that creates coherent sin progression chains (Pride → Injustice → Sin → Demonic Attacks → False Doctrine → Sorcery → Hate and Murder) with interconnected NPCs who have meaningful stakes. The system must be **deterministic and template-driven** (not LLM-generated) to maintain speed and consistency.

Key finding: The existing `bridalFalls` reference town provides a strong foundation showing the required data structures (SinNode[], NPC[], TopicRule[], Location[]). The generation challenge is **combinatorial composition** - creating variety through templates, archetypes, and constraint-based assembly rather than random text generation.

Research reveals three established approaches applicable to this domain:
1. **DitV Town Creation Framework** - The original RPG's structured sin progression with stakeholder mapping
2. **Constraint Satisfaction Problem (CSP)** - Ensures generated towns meet playability requirements
3. **Template-based Grammar Systems** - Creates variety through combinatorial text assembly (Tracery, context-free grammars)

**Primary recommendation:** Build a **generative template system** with validation layer. Generate towns through constraint-solving that selects and combines pre-authored narrative fragments, then validate using graph traversal to ensure discoverability and completability.

## Standard Stack

The project already uses TypeScript/React. For procedural generation, the standard approach is **custom generation logic** rather than heavy libraries, given the domain-specific constraints.

### Core (Project Existing)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| TypeScript | 5.x | Type-safe generation logic | Ensures generated data matches existing types |
| Existing types | Current | TownData, SinNode, NPC, TopicRule | Already defines output schema |

### Supporting (For Generation Logic)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| graphology | 0.25.x | Graph data structures for NPC relationships | Building/validating relationship graphs |
| typescript-graph | Latest | DAG validation, topological sort | Validating sin chain dependencies |
| tracery-grammar | 2.x | Template-based text generation | If using grammar-based text variety (OPTIONAL) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Custom generation | WaveFunctionCollapse lib | WFC is overkill for narrative; designed for spatial constraints |
| Template strings | Tracery grammar | Tracery adds complexity; inline templates sufficient for this scale |
| Custom graph logic | graphology | graphology is battle-tested but adds dependency weight |

**Installation:**
```bash
# Only if graph validation needed beyond simple array operations
npm install graphology

# Only if using grammar-based text generation
npm install tracery-grammar
```

**Recommendation:** Start with **no additional libraries**. Use TypeScript arrays and objects for initial implementation. Add graphology only if relationship graph complexity demands it (>10 NPCs with complex webs).

## Architecture Patterns

### Recommended Project Structure
```
src/
├── generators/
│   ├── townGenerator.ts        # Main orchestrator
│   ├── sinChainGenerator.ts    # Generates sin progression
│   ├── npcGenerator.ts         # Generates NPCs with relationships
│   ├── locationGenerator.ts    # Generates town map
│   ├── topicRuleGenerator.ts   # Generates conversation rules
│   └── validators/
│       ├── sinChainValidator.ts    # Ensures chain is discoverable
│       ├── npcStakesValidator.ts   # Ensures all NPCs have stakes
│       └── playabilityValidator.ts # Overall playability check
├── templates/
│   ├── sinTemplates.ts         # Sin progression templates
│   ├── npcArchetypes.ts        # NPC personality/role templates
│   ├── locationTemplates.ts    # Town layout templates
│   └── relationshipPatterns.ts # NPC relationship archetypes
└── data/
    └── towns/
        ├── bridalFalls.ts      # Hand-crafted reference (existing)
        ├── index.ts            # Exports all towns
        └── [generated].ts      # Runtime or build-time generated towns
```

### Pattern 1: Template-Based Sin Chain Generation

**What:** Sin progressions are generated by selecting from pre-authored templates at each level, then filling "slots" with specific details.

**When to use:** For all town generation. Ensures coherent narrative causality.

**DitV Sin Progression Framework:**
From official DitV town creation and research, the progression structure is:

1. **Pride** - Someone thinks they know better / are better
2. **Injustice** - Pride manifests as unfair treatment of others
3. **Sin** - Someone sins in response (theft, adultery, violence)
4. **Demonic Attacks** - External consequences (plague, famine, raiders)
5. **False Doctrine** - Corrupt religious practices to explain/control problems
6. **Sorcery/False Priesthood** - Active demonic involvement, occult powers
7. **Hate and Murder** - Ultimate escalation, human sacrifice or revenge killing

**Template Example:**
```typescript
// Source: DitV town creation framework + bridalFalls reference
interface SinTemplate {
  level: SinLevel;
  templates: {
    name: string;
    descriptionPattern: string;
    linkedNpcRoles: string[]; // e.g., ["authority-figure", "victim"]
    causeSlot?: string;  // Reference to prior sin level
    effectSlot?: string; // What this enables in next level
  }[];
}

const PRIDE_TEMPLATES: SinTemplate = {
  level: 'pride',
  templates: [
    {
      name: "Authority's Hubris",
      descriptionPattern: "{authority} believes {pronoun} alone knows God's will for {town}.",
      linkedNpcRoles: ["steward", "sheriff", "preacher"],
      effectSlot: "authority-abuse"
    },
    {
      name: "Family Pride",
      descriptionPattern: "The {family-name} family believes they are chosen above others.",
      linkedNpcRoles: ["patriarch", "matriarch"],
      effectSlot: "family-feud"
    },
    // More templates...
  ]
};
```

### Pattern 2: Constraint-Satisfaction NPC Generation

**What:** Generate NPCs by solving constraints (must cover all sin levels, must have relationships, must have opposing interests).

**When to use:** After sin chain is generated. NPCs must map onto the existing sins.

**Constraint System:**
```typescript
// Constraint-based approach from CSP research
interface NPCGenerationConstraints {
  minNPCs: number;          // e.g., 5
  maxNPCs: number;          // e.g., 8

  // Hard constraints (MUST satisfy)
  mustCoverAllSins: boolean;           // Every sin has linked NPC
  mustHaveStakeholders: boolean;       // Each sin has 2+ NPCs with stakes
  mustHaveRelationships: boolean;      // NPCs form connected graph

  // Soft constraints (prefer to satisfy)
  preferDiverseRoles: boolean;         // Avoid role duplicates
  preferBalancedKnowledge: boolean;    // Distribute facts across NPCs
  preferConflictingInterests: boolean; // Create dramatic tension
}

// Generate NPCs by iteratively satisfying constraints
function generateNPCs(
  sinChain: SinNode[],
  constraints: NPCGenerationConstraints
): NPC[] {
  const npcs: NPC[] = [];

  // 1. Create NPCs for each sin level (hard constraint)
  for (const sin of sinChain) {
    const roles = selectRolesForSin(sin.level);
    for (const role of roles) {
      npcs.push(createNPCFromArchetype(role, sin));
    }
  }

  // 2. Add relationship edges (hard constraint)
  const relationshipGraph = buildRelationshipGraph(npcs, sinChain);
  if (!isConnected(relationshipGraph)) {
    addBridgeNPCs(npcs, relationshipGraph);
  }

  // 3. Optimize for soft constraints
  balanceKnowledgeDistribution(npcs);
  ensureConflictingInterests(npcs);

  return npcs;
}
```

### Pattern 3: Validation-Driven Generation

**What:** Generate content, validate playability, regenerate if invalid. Fail fast if constraints unsatisfiable.

**When to use:** As final step before returning generated town.

**Validation Pipeline:**
```typescript
// From procedural generation research on playability testing
interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
}

interface TownValidator {
  validateSinChainDiscoverable(town: TownData): ValidationResult;
  validateAllNPCsHaveStakes(town: TownData): ValidationResult;
  validateNoDeadEnds(town: TownData): ValidationResult;
  validateTopicRulesCoverSins(town: TownData): ValidationResult;
}

function generateTown(seed: string, maxAttempts = 10): TownData {
  for (let i = 0; i < maxAttempts; i++) {
    const candidate = generateTownCandidate(seed + i);
    const validation = validateTown(candidate);

    if (validation.valid) {
      return candidate;
    }

    // Log why it failed for debugging
    console.warn(`Town generation attempt ${i} failed:`, validation.errors);
  }

  throw new Error('Failed to generate valid town after max attempts');
}
```

### Pattern 4: Graph-Based Relationship Modeling

**What:** Model NPC relationships as a directed graph where edges represent relationship types (ally, enemy, family, secret, etc.).

**When to use:** When ensuring NPCs have interconnected stakes and knowledge.

**Implementation:**
```typescript
// From relationship mapping and social graph research
type RelationshipType =
  | 'family'           // Blood relation
  | 'ally'             // Working together
  | 'enemy'            // Opposed interests
  | 'romantic'         // Love/marriage
  | 'secret-keeper'    // Knows secret about other
  | 'victim-of'        // Harmed by other
  | 'protector-of';    // Protecting other

interface NPCRelationship {
  from: string;        // NPC ID
  to: string;          // NPC ID
  type: RelationshipType;
  secret?: boolean;    // Hidden from other NPCs?
  sinId?: string;      // Related to which sin?
}

function buildRelationshipGraph(
  npcs: NPC[],
  sinChain: SinNode[]
): Map<string, NPCRelationship[]> {
  const graph = new Map<string, NPCRelationship[]>();

  // For each sin, create relationships between linked NPCs
  for (const sin of sinChain) {
    const linkedNPCs = npcs.filter(npc =>
      sin.linkedNpcs.includes(npc.id)
    );

    // Create relationship pattern based on sin level
    const pattern = getRelationshipPattern(sin.level);
    addRelationships(graph, linkedNPCs, pattern, sin.id);
  }

  return graph;
}

// From DitV town creation: "if important NPC, they're married - what does spouse want?"
function ensureStakeholderDiversity(
  graph: Map<string, NPCRelationship[]>,
  npcs: NPC[]
): void {
  for (const npc of npcs) {
    if (isImportantRole(npc.role)) {
      // Add family member with different perspective
      const spouse = createRelatedNPC(npc, 'family');
      addOpposingInterest(spouse, npc);
      npcs.push(spouse);
    }
  }
}
```

### Anti-Patterns to Avoid

- **Random Text Generation Without Templates** - Leads to incoherent narratives. Use template slots, not free-form generation.
- **Over-Constraining CSP** - Setting too many hard constraints causes generation failures. Most constraints should be soft.
- **Ignoring DitV Sin Order** - The progression Pride→Injustice→Sin→etc. is weight-bearing for the game's moral framework. Don't skip levels.
- **NPCs Without Stakes** - Every NPC must want something from the Dogs. No "neutral observers."
- **Validation as Afterthought** - Build validation into the generation loop from the start. Don't generate 1000 invalid towns before checking.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Graph connectivity validation | Manual DFS traversal | `typescript-graph` or simple `Set<string>` visited tracking | Easy to get wrong; tested libraries handle edge cases |
| Template text generation with grammar | String concatenation with if/else | Tracery or inline template literals with tagged unions | Grammar systems handle complex expansion rules |
| Seeded random number generation | `Math.random()` | `seedrandom` or simple LCG | Need determinism for same seed = same town |
| Graph cycle detection | Manual traversal | `typescript-graph` DAG validation | Topological sort is well-solved |

**Key insight:** Most generation complexity is in the **template design and constraint logic**, not in data structure algorithms. Use standard graph algorithms but focus effort on domain-specific templates.

## Common Pitfalls

### Pitfall 1: Generating Unwinnable Towns
**What goes wrong:** Sin chain has no discovery path. Player can't learn about sins because facts are gated behind impossible trust levels or circular dependencies.

**Why it happens:** Generating sin chain and NPC knowledge independently without checking discoverability.

**How to avoid:**
- Use **topological sort** on knowledge dependency graph
- Ensure at least one fact per sin has `minTrustLevel: 0` (starter fact)
- Validate that trust can be built through available approaches

**Warning signs:**
- All facts for a sin require trust level >50
- No NPC at a location where player starts
- Topic rules require discoveries that can't be made yet

### Pitfall 2: NPCs With No Stakes
**What goes wrong:** Generated NPCs are just information dispensers. They don't care about the Dogs' judgment.

**Why it happens:** Forgetting that DitV is about moral judgment. NPCs must want specific outcomes.

**How to avoid:**
- Every NPC gets `wants: string` field during generation
- `wants` must conflict with at least one other NPC's wants
- Link wants to sin resolution: "wants Steward punished" vs. "wants Steward protected"

**Warning signs:**
- NPC has knowledge but no opinion
- NPC doesn't care about any sin's resolution
- All NPCs want the same thing (no conflict)

### Pitfall 3: Template Repetition (The "Sameness" Problem)
**What goes wrong:** Generated towns feel identical despite different seeds.

**Why it happens:** Insufficient template variety or always selecting same templates.

**How to avoid:**
- Create minimum **3-5 templates per sin level**
- Use **weighted random selection** seeded by town seed
- Vary not just text but **structure** (3-sin chain vs 5-sin chain vs 7-sin chain)
- Combinatorial variety through archetypes: 5 pride templates × 4 injustice templates × 3 sin templates = 60 combinations

**Warning signs:**
- Same NPC roles in every town (always Steward, always Sheriff)
- Same sin names ("Steward's Pride" in 90% of towns)
- Same location names

### Pitfall 4: Location Generation Without Narrative Purpose
**What goes wrong:** Locations generated for visual variety but don't support investigation.

**Why it happens:** Treating location generation as separate from narrative generation.

**How to avoid:**
- Generate locations **after** sin chain and NPCs
- Each location must either: house an NPC, be referenced in a sin, or provide location-specific topic rule
- Follow bridalFalls pattern: 5 NPCs, 7 locations (NPCs at 5, 2 are discovery sites)

**Warning signs:**
- Locations with no NPCs and no topic rules
- Location connections that isolate NPCs
- Location descriptions that don't hint at sins

### Pitfall 5: Circular Knowledge Dependencies
**What goes wrong:** To learn fact A, you need fact B. To learn fact B, you need fact A. Deadlock.

**Why it happens:** Generating topic rules and knowledge gates without checking dependency graph.

**How to avoid:**
- Build knowledge dependency graph during generation
- Use **topological sort** to validate no cycles
- Ensure at least one "entry point" per sin (fact with no dependencies)

**Warning signs:**
- Topic requires discovery which requires another topic
- All facts about a sin require approach unlocked by that sin
- No default topics lead to discovery-gated topics

## Code Examples

Verified patterns from existing codebase and research:

### Sin Chain Generation (Minimal Example)
```typescript
// Based on bridalFalls.ts structure + DitV framework
import type { SinNode, SinLevel } from '@/types/investigation';

const SIN_CHAIN_ORDER: SinLevel[] = [
  'pride',
  'injustice',
  'sin',
  'demonic-attacks',
  'false-doctrine',
  'sorcery',
  'hate-and-murder'
];

interface SinSlotTemplate {
  level: SinLevel;
  namePattern: string;
  descriptionPattern: string;
  npcRoleSlots: string[];  // Which NPC archetypes link here
}

const PRIDE_TEMPLATES: SinSlotTemplate[] = [
  {
    level: 'pride',
    namePattern: "{authority}'s Pride",
    descriptionPattern: "{authority} believes {pronoun} alone knows God's will for {town}.",
    npcRoleSlots: ['steward', 'preacher', 'elder']
  },
  {
    level: 'pride',
    namePattern: "Family Supremacy",
    descriptionPattern: "The {family} family believes they are chosen above all others.",
    npcRoleSlots: ['patriarch', 'matriarch']
  }
];

function generateSinChain(
  townName: string,
  chainLength: number,  // 3-7
  seed: number
): SinNode[] {
  const selectedLevels = SIN_CHAIN_ORDER.slice(0, chainLength);
  const sinNodes: SinNode[] = [];

  for (const level of selectedLevels) {
    const template = selectTemplate(level, seed);
    const sin: SinNode = {
      id: `sin-${level}-${seed}`,
      level,
      name: fillTemplate(template.namePattern, { townName }),
      description: fillTemplate(template.descriptionPattern, { townName }),
      discovered: false,
      resolved: false,
      linkedNpcs: []  // Filled in during NPC generation
    };
    sinNodes.push(sin);
  }

  return sinNodes;
}
```

### NPC Archetype-Based Generation
```typescript
// From NPC archetype research + bridalFalls pattern
import type { NPC, NPCKnowledge } from '@/types/npc';
import type { LocationId } from '@/types/game';

interface NPCArchetype {
  role: string;
  personalityTemplates: string[];
  speechPatternTemplates: string[];
  defaultLocation: LocationId;
  resistProfile: {
    body: number;    // 0.0-1.0
    will: number;
    heart: number;
    acuity: number;
  };
}

const ARCHETYPES: NPCArchetype[] = [
  {
    role: 'Steward',
    personalityTemplates: [
      'Proud and authoritative. Speaks with absolute certainty.',
      'Rigid and legalistic. Quotes scripture constantly.'
    ],
    speechPatternTemplates: [
      'Declarative statements. Uses "we" meaning "I".',
      'Long-winded sermons. Pauses for effect.'
    ],
    defaultLocation: 'church',
    resistProfile: { body: 0.8, will: 0.4, heart: 0.6, acuity: 0.5 }
  },
  {
    role: 'Midwife',
    personalityTemplates: [
      'Suffering but resilient. Grateful for kindness.',
      'Tired and worn. Protective of patients.'
    ],
    speechPatternTemplates: [
      'Quiet, measured tone. Coughs between sentences.',
      'Soft voice. Avoids direct accusations.'
    ],
    defaultLocation: 'general-store',
    resistProfile: { body: 0.2, will: 0.3, heart: 0.1, acuity: 0.2 }
  }
  // More archetypes...
];

function generateNPC(
  archetype: NPCArchetype,
  linkedSins: SinNode[],
  seed: number
): NPC {
  const personality = selectRandom(archetype.personalityTemplates, seed);
  const speechPattern = selectRandom(archetype.speechPatternTemplates, seed + 1);

  return {
    id: `npc-${archetype.role.toLowerCase()}-${seed}`,
    name: generateName(archetype.role, seed),
    locationId: archetype.defaultLocation,
    description: `The town ${archetype.role.toLowerCase()}.`,
    role: archetype.role,
    knowledge: generateKnowledge(archetype, linkedSins, personality, speechPattern),
    conflictThresholds: [
      { approach: 'body', resistChance: archetype.resistProfile.body },
      { approach: 'will', resistChance: archetype.resistProfile.will },
      { approach: 'heart', resistChance: archetype.resistProfile.heart },
      { approach: 'acuity', resistChance: archetype.resistProfile.acuity }
    ]
  };
}
```

### Knowledge Fact Generation with Gates
```typescript
// Based on bridalFalls NPCKnowledge pattern
import type { KnowledgeFact } from '@/types/dialogue';

interface FactTemplate {
  contentPattern: string;
  tags: string[];
  minTrustLevel: number;
  requiredApproach?: ApproachType;
  sinLevel?: SinLevel;
}

const FACT_TEMPLATES: Record<string, FactTemplate[]> = {
  'steward-pride': [
    {
      contentPattern: 'I alone understand the King of Life\'s will for {town}.',
      tags: ['pride', 'authority'],
      minTrustLevel: 60,
      sinLevel: 'pride'
    },
    {
      contentPattern: 'My word IS the doctrine here.',
      tags: ['pride', 'defiance'],
      minTrustLevel: 80,
      requiredApproach: 'will',
      sinLevel: 'pride'
    }
  ]
  // More templates...
};

function generateKnowledge(
  archetype: NPCArchetype,
  linkedSins: SinNode[],
  personality: string,
  speechPattern: string
): NPCKnowledge {
  const facts: KnowledgeFact[] = [];

  // Always include starter facts (trust 0-20)
  facts.push({
    id: `${archetype.role}-greeting`,
    content: generateGreeting(archetype),
    tags: ['greeting'],
    minTrustLevel: 0
  });

  // Add facts for each linked sin
  for (const sin of linkedSins) {
    const templates = getFactTemplatesForSin(archetype.role, sin.level);
    for (const template of templates) {
      facts.push({
        id: `${archetype.role}-${sin.id}-${facts.length}`,
        content: fillTemplate(template.contentPattern, { town: 'here' }),
        tags: template.tags,
        minTrustLevel: template.minTrustLevel,
        requiredApproach: template.requiredApproach,
        sinId: sin.id
      });
    }
  }

  return {
    npcId: `npc-${archetype.role}`,
    personality,
    speechPattern,
    facts
  };
}
```

### Validation: Sin Chain Discoverability
```typescript
// From graph traversal validation research
function validateSinChainDiscoverable(town: TownData): ValidationResult {
  const errors: ValidationError[] = [];

  // Check 1: Every sin has at least one fact with trust <= 30
  for (const sin of town.sinChain) {
    const factsForSin = town.npcs.flatMap(npc =>
      npc.knowledge?.facts.filter(f => f.sinId === sin.id) || []
    );

    const hasStarterFact = factsForSin.some(f => f.minTrustLevel <= 30);
    if (!hasStarterFact) {
      errors.push({
        type: 'NO_STARTER_FACT',
        message: `Sin "${sin.name}" has no accessible entry point (all facts require trust >30)`,
        sinId: sin.id
      });
    }
  }

  // Check 2: Build dependency graph and check for cycles
  const graph = buildKnowledgeDependencyGraph(town);
  const cycles = detectCycles(graph);
  if (cycles.length > 0) {
    errors.push({
      type: 'CIRCULAR_DEPENDENCY',
      message: `Knowledge graph has circular dependencies: ${cycles.join(', ')}`
    });
  }

  // Check 3: Every sin is reachable from starter facts
  const reachableSins = new Set<string>();
  const visited = new Set<string>();

  function dfs(factId: string) {
    if (visited.has(factId)) return;
    visited.add(factId);

    const fact = findFactById(town, factId);
    if (fact?.sinId) reachableSins.add(fact.sinId);

    const dependencies = graph.get(factId) || [];
    dependencies.forEach(dfs);
  }

  // Start DFS from all starter facts
  const starterFacts = getAllStarterFacts(town);
  starterFacts.forEach(f => dfs(f.id));

  for (const sin of town.sinChain) {
    if (!reachableSins.has(sin.id)) {
      errors.push({
        type: 'UNREACHABLE_SIN',
        message: `Sin "${sin.name}" cannot be discovered from starter facts`,
        sinId: sin.id
      });
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings: []
  };
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Pure LLM generation | Hybrid: templates + LLM refinement | 2024-2025 | Better coherence, controllability |
| Random generation | Constraint satisfaction | 2023-2025 | Ensures playability from start |
| Post-generation validation | Validation-driven generation | 2024-2025 | Fewer invalid outputs, faster iteration |
| Spatial WFC only | WFC for narrative + spatial | 2024-2025 | Applicable to story generation |
| Manual town authoring | Procedural with hand-crafted seeds | Ongoing | Replayability while maintaining quality |

**Deprecated/outdated:**
- **Pure random text generation** - Replaced by template systems with grammar rules (Tracery, etc.)
- **Generate-and-hope** - Replaced by CSP-based generation with built-in validation
- **Monolithic generation functions** - Replaced by composable generator pipeline (chain → NPCs → locations → rules)

**Current best practices (2025-2026):**
- **Template combinatorics** for variety without LLM cost
- **Multi-layer validation** (technical, narrative, gameplay)
- **Constraint satisfaction** with soft/hard constraint separation
- **Graph-based validation** for discoverability and completeness
- **Deterministic seeded generation** for reproducibility

## Open Questions

Things that couldn't be fully resolved:

1. **Action Generation Integration**
   - What we know: Actions are currently hardcoded (`AvailableAction[]`), action resolution is stubbed
   - What's unclear: Should actions be generated per-town or remain universal? Do generated sins need custom actions?
   - Recommendation: Defer action generation to Phase 7 (Action Resolution). For Phase 6, generate placeholder actions or rely on universal action set.

2. **Template Quantity vs. Quality**
   - What we know: Need 3-5 templates per sin level minimum for variety
   - What's unclear: Optimal number before diminishing returns? Hand-author vs. procedurally combine sub-templates?
   - Recommendation: Start with **3 templates per level** (21 templates total for 7 levels). Measure player perception of variety. Sub-template combination adds complexity—defer unless needed.

3. **Location Generation Complexity**
   - What we know: bridalFalls uses hand-crafted SVG coordinates, connection graph
   - What's unclear: Generate layouts procedurally or use fixed templates? SVG coordinate generation algorithm?
   - Recommendation: Phase 6-01 hand-crafts second reference town. Evaluate if layout variety matters or if 3-5 fixed layouts suffice.

4. **Runtime vs. Build-Time Generation**
   - What we know: TownData is currently imported statically
   - What's unclear: Generate towns at runtime (client-side) or build-time (pre-generate pool)?
   - Recommendation: Start with **build-time generation** (script generates towns, commits to repo). Easier debugging, faster load times. Runtime generation in Phase 7+ if needed for infinite variety.

5. **Seed Input**
   - What we know: Need deterministic generation
   - What's unclear: Who provides seed? Player-entered, auto-generated, hash of player name?
   - Recommendation: Phase 6 uses **hardcoded seeds** for generated towns (e.g., "town-002", "town-003"). Phase 8+ can add player seed input.

## Sources

### Primary (HIGH confidence)
- bridalFalls.ts - Reference implementation showing required data structures and content patterns
- TownData/SinNode/NPC TypeScript types - Schema validation for generation output
- [Dogs in the Vineyard town creation framework](https://heterogenoustasks.wordpress.com/2016/11/11/assorted-cool-things-about-dogs-in-the-vineyard/) - Official sin progression structure, stakeholder mapping
- [Dogs in the Vineyard RPG Writeups](https://writeups.letsyouandhimfight.com/professorprof/dogs-in-the-vineyard/) - Sin escalation chain details

### Secondary (MEDIUM confidence)
- [Creating Epic Quest Chains with Branching Narratives](https://www.questful.dev/blog/quests/creating-epic-quest-chains-with-branching-narrativ) - Validation approaches, playability testing
- [Procedural Text Generation in IF](https://emshort.blog/2014/11/18/procedural-text-generation-in-if/) - Emily Short's guide to template systems, variable substitution, best practices
- [Constraint Programming for Game Design](https://www.wayline.io/blog/constraint-programming-rethinking-game-design) - CSP for narrative generation, over/under-constraining pitfalls
- [Procedural Content Generation in 2025](https://playgama.com/blog/general/crafting-engaging-games-master-procedural-content-generation/) - Template combinatorics, variety vs. sameness
- [Graphology library documentation](https://graphology.github.io/) - TypeScript graph data structures
- [Tracery grammar library](https://github.com/galaxykate/tracery) - Template-based text generation

### Tertiary (LOW confidence - requires validation)
- [WaveFunctionCollapse](https://github.com/mxgmn/WaveFunctionCollapse) - Constraint-based generation (spatial focus, may not apply to narrative)
- [NPC Relationship Mapping](https://gnomestew.com/relationship-mapping/) - Social graph patterns (general RPG advice, not procedural)
- [Playable Game Generation](https://arxiv.org/abs/2412.00887) - Academic research on validation (not specific to narrative)
- WebSearch results on procedural generation - General patterns, not implementation-specific

## Metadata

**Confidence breakdown:**
- Standard stack: **MEDIUM** - TypeScript is confirmed, graph libraries are optional recommendations without direct verification
- Architecture: **HIGH** - Based on existing codebase structure (bridalFalls, types) and verified DitV framework
- Pitfalls: **MEDIUM** - Derived from general procedural generation research and CSP sources, not DitV-specific
- Code examples: **HIGH** - Directly based on bridalFalls.ts patterns and TypeScript type definitions

**Research date:** 2026-01-22
**Valid until:** ~2026-02-22 (30 days - stable domain, not fast-moving)

**Key gaps requiring Phase 6 implementation to resolve:**
1. Exact template count needed for variety (need playtesting)
2. Action generation scope (deferred to Phase 7)
3. Runtime vs. build-time generation (architectural decision)
4. Location layout generation algorithm (hand-craft second town first)
