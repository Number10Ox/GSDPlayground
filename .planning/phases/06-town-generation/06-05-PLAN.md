---
phase: 06-town-generation
plan: 05
type: execute
wave: 5
depends_on: ["06-04"]
files_modified:
  - src/data/towns/index.ts
  - src/components/TownSelection/TownSelection.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Player can choose between bridalFalls and at least 2 generated towns"
    - "Selected town loads correctly with all systems working"
    - "Generated towns are pre-built at import time (not runtime)"
    - "TownProvider receives the selected town"
  artifacts:
    - path: "src/data/towns/index.ts"
      provides: "Export array of all available towns (1 hand-crafted + 2 generated)"
      exports: ["bridalFalls", "ALL_TOWNS", "getTownById"]
    - path: "src/components/TownSelection/TownSelection.tsx"
      provides: "Town selection screen before gameplay starts"
      exports: ["TownSelection"]
    - path: "src/App.tsx"
      provides: "Updated to show town selection, then pass chosen town to TownProvider"
  key_links:
    - from: "src/data/towns/index.ts"
      to: "src/generators/townGenerator.ts"
      via: "calls generateValidTown at module load"
      pattern: "generateValidTown"
    - from: "src/App.tsx"
      to: "src/components/TownSelection/TownSelection.tsx"
      via: "renders TownSelection when no town selected"
      pattern: "TownSelection"
    - from: "src/App.tsx"
      to: "src/hooks/useTown.tsx"
      via: "passes selected town to TownProvider"
      pattern: "TownProvider.*town="
---

<objective>
Generate pre-built towns, create a town selection screen, and wire it into the app so players can choose which town to investigate.

Purpose: This makes town generation real and visible. Players see multiple playable towns and select one. The integration proves the full pipeline works end-to-end from seed to playable game.

Output: App loads with a town selection screen showing 3 towns (1 hand-crafted + 2 generated). Selecting a town starts the game with that town's data flowing through all providers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/App.tsx
@src/hooks/useTown.tsx
@src/data/towns/index.ts
@src/data/towns/bridalFalls.ts
@.planning/phases/06-town-generation/06-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pre-generate towns and update index</name>
  <files>src/data/towns/index.ts</files>
  <action>
Update `src/data/towns/index.ts`:
- Keep existing `export { bridalFalls } from './bridalFalls'`
- Import `generateValidTown` from `@/generators/townGenerator`
- Generate 2 additional towns at module load time using fixed seeds:
  ```
  const hollowCreek = generateValidTown({ seed: 'hollow-creek-001', chainLength: 5, name: 'Hollow Creek' });
  const shepherdsRidge = generateValidTown({ seed: 'shepherds-ridge-001', chainLength: 6, name: "Shepherd's Ridge" });
  ```
- Export `ALL_TOWNS: TownData[]` containing [bridalFalls, hollowCreek, shepherdsRidge]
- Export `getTownById(id: string): TownData | undefined` helper
- Export individual generated towns for direct access

Why fixed seeds with explicit names: Deterministic output, debuggable, same towns every build. Seeds can be expanded later for more variety.

Why chainLength 5 and 6: Varied difficulty. bridalFalls has 4, new towns have 5 and 6, showing progression works at different lengths.
  </action>
  <verify>
`npx tsc --noEmit` passes. Import `ALL_TOWNS` - verify length is 3, each has valid TownData shape, no duplicate IDs.
  </verify>
  <done>3 towns available (1 hand-crafted + 2 generated). All export as valid TownData. Generated towns have longer sin chains than bridalFalls.</done>
</task>

<task type="auto">
  <name>Task 2: Town selection UI and App integration</name>
  <files>src/components/TownSelection/TownSelection.tsx, src/App.tsx</files>
  <action>
Create `src/components/TownSelection/TownSelection.tsx`:
- Import ALL_TOWNS from data/towns
- Import TownData from types/town
- Props: `{ onSelectTown: (town: TownData) => void }`
- Render a selection screen with atmospheric DitV styling:
  - Title: "Choose Your Destination" or "The Road Ahead"
  - Subtitle: Brief atmospheric text about Dogs traveling between towns
  - For each town in ALL_TOWNS, render a card showing:
    - Town name (large, serif font)
    - Town description
    - Sin chain length indicator (e.g., "Corruption: [|||....]" showing depth)
    - NPC count (e.g., "5 souls")
    - "Enter Town" button
  - Cards use Tailwind: bg-stone-800, border-stone-600, hover:border-amber-500 transition
  - Layout: flex column on mobile, flex row on desktop (lg:flex-row)
- Add data-testid="town-selection" on container, data-testid="town-card-{id}" on each card, data-testid="select-town-{id}" on buttons

Update `src/App.tsx`:
- Add React state: `const [selectedTown, setSelectedTown] = useState<TownData | null>(null)`
- If selectedTown is null: render `<TownSelection onSelectTown={setSelectedTown} />`
- If selectedTown is set: render existing provider tree with `<TownProvider town={selectedTown}>`
- Remove hardcoded `bridalFalls` import (now comes from selection)
- Keep all existing providers and GameView unchanged
  </action>
  <verify>
`npx tsc --noEmit` passes. `npm run dev` shows town selection screen on load. Clicking a town card loads the game with that town. Navigation, dialogue, investigation all work with the selected town's data.
  </verify>
  <done>Town selection screen displays 3 towns with atmospheric UI. Selecting a town starts the game. All existing gameplay systems work with any selected town.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run dev` shows town selection on initial load
- All 3 town cards are visible with names, descriptions, sin depth indicators
- Clicking "Enter Town" on bridalFalls loads the existing game experience
- Clicking generated towns loads a different town with different NPCs/locations
- No console errors on any town selection
- data-testid attributes present for E2E testing
</verification>

<success_criteria>
- 3 playable towns available (1 hand-crafted, 2 generated)
- Town selection UI is atmospheric and informative
- Game loads correctly with any selected town
- All existing systems (dialogue, investigation, conflict) work with generated towns
</success_criteria>

<output>
After completion, create `.planning/phases/06-town-generation/06-05-SUMMARY.md`
</output>
