---
phase: 06-town-generation
plan: 03
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - src/templates/locationTemplates.ts
  - src/generators/locationGenerator.ts
  - src/generators/topicRuleGenerator.ts
  - src/generators/townGenerator.ts
autonomous: true

must_haves:
  truths:
    - "Locations are generated with SVG coordinates and connection graphs"
    - "Every NPC has a location assignment"
    - "Topic rules are generated covering default, discovery-gated, and location-specific patterns"
    - "Town assembler produces complete TownData matching existing interface"
    - "Every sin is reachable via topic rules (no dead-end sins)"
  artifacts:
    - path: "src/templates/locationTemplates.ts"
      provides: "Location layout templates with SVG coordinates"
      exports: ["LOCATION_TEMPLATES", "LocationLayout"]
    - path: "src/generators/locationGenerator.ts"
      provides: "Location generation from templates"
      exports: ["generateLocations"]
    - path: "src/generators/topicRuleGenerator.ts"
      provides: "Topic rule generation from NPC/sin data"
      exports: ["generateTopicRules"]
    - path: "src/generators/townGenerator.ts"
      provides: "Main town assembly orchestrator"
      exports: ["generateTown"]
  key_links:
    - from: "src/generators/townGenerator.ts"
      to: "src/generators/sinChainGenerator.ts"
      via: "calls generateSinChain"
      pattern: "generateSinChain"
    - from: "src/generators/townGenerator.ts"
      to: "src/generators/npcGenerator.ts"
      via: "calls generateNPCs"
      pattern: "generateNPCs"
    - from: "src/generators/townGenerator.ts"
      to: "src/generators/locationGenerator.ts"
      via: "calls generateLocations"
      pattern: "generateLocations"
    - from: "src/generators/townGenerator.ts"
      to: "src/generators/topicRuleGenerator.ts"
      via: "calls generateTopicRules"
      pattern: "generateTopicRules"
    - from: "src/generators/townGenerator.ts"
      to: "src/types/town.ts"
      via: "returns TownData"
      pattern: "TownData"
---

<objective>
Create location templates, location generator, topic rule generator, and the main town assembly orchestrator.

Purpose: Locations provide the spatial structure for investigation. Topic rules define conversation access patterns. The town generator orchestrates all sub-generators into a complete TownData object ready for gameplay.

Output: A working `generateTown(seed)` function that produces a complete `TownData` object by orchestrating sin chain, NPC, location, and topic rule generation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-town-generation/06-RESEARCH.md
@src/types/town.ts
@src/types/game.ts
@src/data/towns/bridalFalls.ts
@src/utils/topicResolver.ts
@.planning/phases/06-town-generation/06-01-SUMMARY.md
@.planning/phases/06-town-generation/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Location templates and location generator</name>
  <files>src/templates/locationTemplates.ts, src/generators/locationGenerator.ts</files>
  <action>
Create `src/templates/locationTemplates.ts`:
- Export `LocationSlot` interface: `{ type: string; nameVariants: string[]; descriptionVariants: string[]; x: number; y: number; connections: string[] }`
- Export `LocationLayout` interface: `{ id: string; slots: LocationSlot[] }`
- Export `LOCATION_TEMPLATES: LocationLayout[]` with 3 different town layouts:
  1. "hub-and-spoke": Central square (500,400) connected to 5-6 surrounding locations (church, store, office, homestead, well, cemetery) - similar to bridalFalls
  2. "linear-road": Main street layout with locations along a line, branching paths at ends
  3. "clustered": Two clusters (residential + commercial) connected by a bridge location
- Each layout has 6-8 location slots with pre-computed SVG coordinates (0-1000 x, 0-800 y range)
- Location slot types: 'church', 'store', 'office', 'homestead', 'gathering', 'landmark', 'outskirts'
- LocationSlot has `nameVariants: string[]` and `descriptionVariants: string[]`. Generator uses RNG.pick() to select one variant per slot. Each slot should have 2+ name variants and 2+ description variants for variety.

Create `src/generators/locationGenerator.ts`:
- Import Location from game.ts, createRNG from seededRandom, LOCATION_TEMPLATES from templates
- Export `generateLocations(npcCount: number, seed: string): Location[]`:
  1. Select layout template using RNG (pick from LOCATION_TEMPLATES)
  2. Select enough slots to cover npcCount + 2 discovery locations
  3. For each slot, use `rng.pick(slot.nameVariants)` and `rng.pick(slot.descriptionVariants)` to select one name and one description
  4. Generate Location[] with proper IDs (kebab-case of selected name), coordinates from template, connections from template
  5. Ensure connection graph is connected (every location reachable from every other)
  6. Return Location[]

Key: Coordinates are fixed per-template (not randomly generated) to ensure readable SVG maps. Variety comes from which template is selected and which name/description variants are picked per slot.
  </action>
  <verify>
`npx tsc --noEmit` passes. `generateLocations(5, "test")` returns 7+ locations with valid SVG coordinates (x: 0-1000, y: 0-800) and connected graphs. Same seed = same locations. Different seeds can select different name variants.
  </verify>
  <done>3 location layout templates with pre-computed coordinates and name/description variants per slot. Generator produces connected location graphs with proper SVG positions and RNG-selected variant names.</done>
</task>

<task type="auto">
  <name>Task 2: Topic rule generator and town assembler</name>
  <files>src/generators/topicRuleGenerator.ts, src/generators/townGenerator.ts</files>
  <action>
Create `src/generators/topicRuleGenerator.ts`:
- Import TopicRule types from town.ts, NPC from npc.ts, SinNode from investigation.ts
- Export `generateTopicRules(npcs: NPC[], sinChain: SinNode[], locations: Location[]): TopicRule[]`:
  1. Always add 2 default topics: 'greeting', 'the-town'
  2. For each sin node: create a DiscoveryTopicRule with label derived from sin name (kebab-case), requiredSinIds = [sin.id]
  3. For each NPC: create a LocationTopicRule for their home location with a location-specific topic label (e.g., 'chapel-doctrine' for church NPC)
  4. Ensure every sin has at least one discovery-gated topic that references it
  5. Return TopicRule[]
- Generated rules must be compatible with existing `resolveTopicsForNPC()` in topicResolver.ts

Create `src/generators/townGenerator.ts`:
- Import all generators: generateSinChain, generateNPCs, generateLocations, generateTopicRules
- Import TownData from town.ts
- Import createRNG from seededRandom

Export `TownGenerationConfig`: `{ seed: string; chainLength?: number; name?: string }`

Export `generateTown(config: TownGenerationConfig): TownData`:
  1. Create RNG from config.seed
  2. Generate town name (if not provided): Use RNG to pick from a list of 20+ frontier town name fragments (e.g., "Bridal", "Hollow", "Red", "Shepherd's" + "Falls", "Creek", "Ridge", "Crossing")
  3. Generate sin chain: `generateSinChain(config.seed, config.chainLength ?? 4)`
  4. Generate NPCs: `generateNPCs(sinChain, config.seed)`
  5. Generate locations: `generateLocations(npcs.length, config.seed + "-loc")`
  6. Assign NPCs to locations: Map NPC defaultLocationType to actual location IDs from generated locations
  7. Generate topic rules: `generateTopicRules(npcs, sinChain, locations)`
  8. Assemble TownData: `{ id: kebab(name), name, description, locations, npcs, sinChain: updatedSinChain, topicRules }`
  9. Return complete TownData

Export `TOWN_NAME_FRAGMENTS` for testing/variety checking.

Key constraints:
- Output must satisfy TownData interface exactly
- NPC locationId values must reference actual location IDs
- Topic rule npcId/locationId values must reference actual NPCs/locations
- Town description should be atmospheric and hint at the sin chain's theme
  </action>
  <verify>
`npx tsc --noEmit` passes. `generateTown({ seed: "test-town" })` returns a complete TownData. Verify: result.locations.length >= 6, result.npcs.length >= 5, result.sinChain.length >= 3, result.topicRules.length >= 7. All NPC locationIds exist in locations array. All topic rule references are valid.
  </verify>
  <done>Topic rule generator produces valid rules covering all sins. Town assembler orchestrates all generators into complete, self-consistent TownData objects.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `generateTown({ seed: "abc" })` produces valid TownData
- All NPC.locationId values exist in locations array
- All TopicRule npcId/locationId references are valid
- Location connection graph is connected
- Default topics + discovery topics + location topics all present
- Same seed = same town (deterministic)
- resolveTopicsForNPC works with generated topic rules
</verification>

<success_criteria>
- 3 distinct location layout templates with name/description variants per slot
- Topic rules automatically cover all sins in generated chain
- Town assembler produces complete, self-consistent TownData
- Generated towns pass basic structural integrity (all references valid)
</success_criteria>

<output>
After completion, create `.planning/phases/06-town-generation/06-03-SUMMARY.md`
</output>
