---
phase: 06-town-generation
plan: 04
type: execute
wave: 4
depends_on: ["06-03"]
files_modified:
  - src/generators/validators/sinChainValidator.ts
  - src/generators/validators/npcStakesValidator.ts
  - src/generators/validators/playabilityValidator.ts
  - src/generators/townGenerator.ts
autonomous: true

must_haves:
  truths:
    - "Validator catches towns with unreachable sins (no starter facts)"
    - "Validator catches towns with unlinked NPCs (no stakes)"
    - "Validator catches circular knowledge dependencies"
    - "Generator retries on validation failure (up to 10 attempts)"
    - "Valid towns pass all three validators without errors"
  artifacts:
    - path: "src/generators/validators/sinChainValidator.ts"
      provides: "Sin chain discoverability validation"
      exports: ["validateSinChainDiscoverable"]
    - path: "src/generators/validators/npcStakesValidator.ts"
      provides: "NPC stakes and relationship validation"
      exports: ["validateNPCStakes"]
    - path: "src/generators/validators/playabilityValidator.ts"
      provides: "Overall playability check"
      exports: ["validatePlayability", "validateTown"]
    - path: "src/generators/townGenerator.ts"
      provides: "Updated with validate-retry loop"
      exports: ["generateTown", "generateValidTown"]
  key_links:
    - from: "src/generators/validators/playabilityValidator.ts"
      to: "src/generators/validators/sinChainValidator.ts"
      via: "composes all validators"
      pattern: "validateSinChainDiscoverable"
    - from: "src/generators/validators/playabilityValidator.ts"
      to: "src/generators/validators/npcStakesValidator.ts"
      via: "composes all validators"
      pattern: "validateNPCStakes"
    - from: "src/generators/townGenerator.ts"
      to: "src/generators/validators/playabilityValidator.ts"
      via: "validate-retry loop"
      pattern: "validateTown|validatePlayability"
---

<objective>
Create the validation pipeline and integrate it into the town generator with a retry loop.

Purpose: Validation ensures generated towns are actually playable. Without it, generation can produce unwinnable scenarios (unreachable sins, isolated NPCs, circular dependencies). The validate-retry loop guarantees every output town is playable.

Output: Three validators (sin chain, NPC stakes, playability) and an updated town generator with `generateValidTown()` that retries until validation passes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-town-generation/06-RESEARCH.md
@src/types/town.ts
@src/types/npc.ts
@src/types/investigation.ts
@src/types/dialogue.ts
@.planning/phases/06-town-generation/06-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sin chain and NPC validators</name>
  <files>src/generators/validators/sinChainValidator.ts, src/generators/validators/npcStakesValidator.ts</files>
  <action>
Create `src/generators/validators/sinChainValidator.ts`:
- Export `ValidationError`: `{ type: string; message: string; sinId?: string; npcId?: string }`
- Export `ValidationResult`: `{ valid: boolean; errors: ValidationError[]; warnings: ValidationError[] }`
- Export `validateSinChainDiscoverable(town: TownData): ValidationResult`:
  1. Check every sin has at least one NPC fact with `minTrustLevel <= 30` and matching sinId (starter fact accessible early)
  2. Check no circular knowledge dependencies:
     - Build dependency graph: discovery-gated topic rules create edges (discovering sin A unlocks topics that can reveal sin B)
     - Detect cycles using iterative DFS with a visited/inStack set
  3. Check every sin is reachable from default topics:
     - Start from facts accessible via default topics (trust 0 facts)
     - BFS through discovery gates (discovering sin X unlocks topics for sin Y)
     - Any sin not reachable = error
  4. Warning (not error): If a sin has only one NPC with knowledge about it (single point of failure)

Create `src/generators/validators/npcStakesValidator.ts`:
- Export `validateNPCStakes(town: TownData): ValidationResult`:
  1. Check every NPC has at least one fact with a sinId (NPC has stakes in some sin)
  2. Check every sin has 2+ NPCs in its linkedNpcs array
  3. Check NPC relationship graph is connected:
     - Use the relationships from NPCGenerationResult (stored on town or passed separately)
     - If relationships not available, check that every NPC shares at least one sinId with another NPC (implicit connection)
  4. Check every NPC has at least one fact at trust level 0 (greeting/entry point)
  5. Warning: NPCs with >80% of facts at trust 60+ (too secretive, hard to crack)
  </action>
  <verify>
`npx tsc --noEmit` passes. Test with bridalFalls data: `validateSinChainDiscoverable(bridalFalls)` returns `{ valid: true }`. Test with a deliberately broken town (all facts trust 100): returns `{ valid: false, errors: [...] }`.
  </verify>
  <done>Sin chain validator catches unreachable sins and circular dependencies. NPC validator catches stakeless NPCs and disconnected relationships.</done>
</task>

<task type="auto">
  <name>Task 2: Playability validator and generate-validate loop</name>
  <files>src/generators/validators/playabilityValidator.ts, src/generators/townGenerator.ts</files>
  <action>
Create `src/generators/validators/playabilityValidator.ts`:
- Import validateSinChainDiscoverable and validateNPCStakes
- Export `validatePlayability(town: TownData): ValidationResult`:
  1. Check all NPC locationIds exist in town.locations
  2. Check all TopicRule npcId/locationId references are valid
  3. Check location connection graph is connected (BFS from first location)
  4. Check topic rules cover all sin levels (every sin has at least one discovery rule referencing it)
  5. Aggregate errors/warnings from structural checks
- Export `validateTown(town: TownData): ValidationResult`:
  1. Run validateSinChainDiscoverable
  2. Run validateNPCStakes
  3. Run validatePlayability
  4. Merge all results: valid = all three valid, errors = concat, warnings = concat
  5. Return merged ValidationResult

Update `src/generators/townGenerator.ts`:
- Import validateTown from validators
- Keep existing `generateTown(config)` as the single-attempt generator
- Add export `generateValidTown(config: TownGenerationConfig, maxAttempts = 10): TownData`:
  1. For i = 0 to maxAttempts-1:
     a. Call `generateTown({ ...config, seed: config.seed + (i > 0 ? `-retry-${i}` : '') })`
     b. Call `validateTown(candidate)`
     c. If valid, return candidate
     d. If invalid, log warnings to console.warn with attempt number and errors
  2. If all attempts fail, throw Error with last validation errors
- This pattern ensures the exported function always returns a playable town or throws explicitly
  </action>
  <verify>
`npx tsc --noEmit` passes. `validateTown(bridalFalls)` returns `{ valid: true }`. `generateValidTown({ seed: "test" })` returns a town where `validateTown(result).valid === true`. Verify retry logic: mock a generator that fails first N times, confirm it retries and eventually succeeds.
  </verify>
  <done>Playability validator catches all structural issues. generateValidTown retries on failure and guarantees playable output. bridalFalls passes all validators.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `validateTown(bridalFalls)` returns valid: true (existing hand-crafted town passes)
- `generateValidTown({ seed: "any-seed" })` returns a town that passes `validateTown()`
- Deliberately broken input (empty sinChain, no NPC facts) produces specific error messages
- Retry mechanism works: different seed suffix on each attempt
- All validation errors have descriptive messages identifying the specific problem
</verification>

<success_criteria>
- Three focused validators each catch specific failure modes
- Combined validator runs all checks and merges results
- Generate-validate loop guarantees playable output
- Existing bridalFalls town passes all validation
- Error messages are actionable (identify which sin/NPC/location failed)
</success_criteria>

<output>
After completion, create `.planning/phases/06-town-generation/06-04-SUMMARY.md`
</output>
