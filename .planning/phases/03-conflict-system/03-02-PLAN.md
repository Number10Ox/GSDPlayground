---
phase: 03-conflict-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/Conflict/ConflictView.tsx
  - src/components/Conflict/EscalationIndicator.tsx
  - src/components/Conflict/EscalationConfirm.tsx
  - src/components/Conflict/RaiseControls.tsx
  - src/components/Conflict/BiddingHistory.tsx
  - src/components/Conflict/index.ts
autonomous: true

must_haves:
  truths:
    - "Player can select exactly 2 dice to raise"
    - "Player can select dice to see that meet or exceed raise total"
    - "Escalation requires confirmation with internal monologue"
    - "Turn history shows all raises and sees with descriptions"
  artifacts:
    - path: "src/components/Conflict/ConflictView.tsx"
      provides: "Main conflict UI orchestrator"
      exports: ["ConflictView"]
    - path: "src/components/Conflict/RaiseControls.tsx"
      provides: "Dice selection for raise/see actions"
      exports: ["RaiseControls"]
    - path: "src/components/Conflict/EscalationConfirm.tsx"
      provides: "Modal with internal monologue for escalation"
      exports: ["EscalationConfirm"]
    - path: "src/components/Conflict/BiddingHistory.tsx"
      provides: "Turn-by-turn log of conflict actions"
      exports: ["BiddingHistory"]
  key_links:
    - from: "src/components/Conflict/ConflictView.tsx"
      to: "src/reducers/conflictReducer.ts"
      via: "useReducer for conflict state"
      pattern: "useReducer.*conflictReducer"
    - from: "src/components/Conflict/ConflictView.tsx"
      to: "src/hooks/useConflictAtmosphere.ts"
      via: "CSS variable theming"
      pattern: "useConflictAtmosphere"
---

<objective>
Build the conflict UI components: main orchestrator, raise/see controls, escalation confirmation, and bidding history.

Purpose: Enable player to engage in raise/see bidding with visual feedback and escalation confirmation.
Output: Complete conflict UI that handles the core bidding loop.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-conflict-system/03-CONTEXT.md
@.planning/phases/03-conflict-system/03-RESEARCH.md
@.planning/phases/03-conflict-system/03-01-SUMMARY.md

# Existing UI patterns
@src/components/CycleView/CycleView.tsx
@src/components/DicePool/DicePool.tsx
@src/components/DicePool/DieComponent.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: RaiseControls and EscalationConfirm components</name>
  <files>src/components/Conflict/RaiseControls.tsx, src/components/Conflict/EscalationConfirm.tsx</files>
  <action>
**RaiseControls.tsx:**

Create dice selection component for raise/see actions:

1. Props: `{ dice: Die[], mode: 'RAISE' | 'SEE', raiseTotal?: number, onSubmit: (dice: Die[]) => void, onGive: () => void }`

2. Local state: `selectedDiceIds: string[]` (array for multi-select)

3. Render dice using DieComponent pattern from DicePool:
   - Click toggles selection (add/remove from selectedDiceIds)
   - Selected dice highlighted (similar to DicePool selection)
   - data-testid="raise-die-{id}" for E2E

4. For RAISE mode:
   - Enable submit only when exactly 2 dice selected
   - Button text: "Raise" with total shown
   - data-testid="raise-submit-button"

5. For SEE mode:
   - Calculate selected total, compare to raiseTotal
   - Enable submit only when total >= raiseTotal
   - Show "See (total)" or "Not enough (need X more)"
   - data-testid="see-submit-button"

6. "Give" button always available:
   - data-testid="give-button"
   - Confirm dialog before calling onGive

7. Use Framer Motion for selection animations (scale/glow on select)

**EscalationConfirm.tsx:**

Create modal for escalation confirmation with internal monologue:

1. Props: `{ currentLevel: EscalationLevel, targetLevel: EscalationLevel, onConfirm: () => void, onCancel: () => void }`

2. ESCALATION_MONOLOGUES constant - 3-5 hand-written monologues per level:
   - PHYSICAL: "Your hands clench into fists...", "You step closer, making your presence felt...", etc.
   - FIGHTING: "Your hand moves to your belt...", "The time for words is past...", etc.
   - GUNPLAY: "Your hand moves toward the gun. Once drawn, there's no taking it back.", "The weight of the iron at your hip suddenly feels heavier...", etc.

3. Render modal overlay with:
   - Current level indicator
   - Target level indicator
   - Randomly selected monologue for target level
   - "This cannot be undone" warning
   - Confirm/Cancel buttons
   - For GUNPLAY: longer pause before confirm button enables (1.5s delay)
   - data-testid="escalation-confirm-modal"

4. Framer Motion entrance animation (fade in, slight scale)
  </action>
  <verify>`npx tsc --noEmit` passes. Components render without errors in isolation.</verify>
  <done>RaiseControls validates 2 dice for raise, >= total for see. EscalationConfirm shows monologue with delay for gunplay.</done>
</task>

<task type="auto">
  <name>Task 2: EscalationIndicator and BiddingHistory components</name>
  <files>src/components/Conflict/EscalationIndicator.tsx, src/components/Conflict/BiddingHistory.tsx</files>
  <action>
**EscalationIndicator.tsx:**

Create split escalation display showing both player and NPC levels:

1. Props: `{ playerLevel: EscalationLevel, npcLevel: EscalationLevel, npcName: string }`

2. Layout: Two columns side by side
   - Left: "You" + playerLevel badge
   - Right: npcName + npcLevel badge

3. Level badges show canonical DitV names with color coding:
   - JUST_TALKING: gray/neutral
   - PHYSICAL: amber/orange
   - FIGHTING: red
   - GUNPLAY: dark red/crimson

4. When level changes, flash/pulse animation (Framer Motion animate prop with keyframes)

5. data-testid="player-escalation-{level}" and data-testid="npc-escalation-{level}"

**BiddingHistory.tsx:**

Create scrollable turn history log:

1. Props: `{ turns: ConflictTurn[], currentRaise: { dice: Die[], total: number } | null }`

2. Render each turn as a card:
   - Actor name (You/NPC name)
   - Action type (Raise/See/Escalate/Give)
   - Dice used (small die icons)
   - Description text

3. For RAISE: Show dice and total ("Raised 7 with [d6:4] [d4:3]")

4. For SEE: Show type based on dice count:
   - 1 die: "Reversed the Blow"
   - 2 dice: "Blocked/Dodged"
   - 3+ dice: "Took the Blow" (highlight as dangerous)

5. For ESCALATE: Show level transition and monologue

6. If currentRaise exists, show pending raise at top with "Waiting for response..."

7. Auto-scroll to bottom when new turn added (useEffect with ref)

8. data-testid="bidding-history"
  </action>
  <verify>`npx tsc --noEmit` passes. Components render history correctly with mock data.</verify>
  <done>EscalationIndicator shows split levels with color badges. BiddingHistory shows turn-by-turn log with auto-scroll.</done>
</task>

<task type="auto">
  <name>Task 3: ConflictView orchestrator and barrel export</name>
  <files>src/components/Conflict/ConflictView.tsx, src/components/Conflict/index.ts</files>
  <action>
**ConflictView.tsx:**

Create main conflict orchestrator following CycleView.tsx pattern:

1. Use `useReducer(conflictReducer, initialConflictState)` for local conflict state

2. Call `useConflictAtmosphere()` with highest escalation level when conflict active

3. Render based on conflict phase:

   **INACTIVE:** Return null (conflict not started - triggered externally)

   **ACTIVE:**
   - Full-screen overlay (similar to CycleView wake/rest overlays)
   - Header: Stakes displayed prominently
   - EscalationIndicator showing both levels
   - Main area: Player's dice pool + RaiseControls
   - Sidebar: BiddingHistory
   - Escalate buttons (only show levels above current)
   - Layout: Flexbox with history on left, controls center, pool on right

   **RESOLVED:**
   - Show outcome message: "You won/lost [stakes]"
   - Show fallout result with severity
   - "Brother [NPC] will remember this" if violent
   - Continue button to dismiss

4. Handle escalation flow:
   - Click escalate button -> show EscalationConfirm modal
   - On confirm -> dispatch PLAYER_ESCALATE
   - Animate new dice entering pool (Framer Motion AnimatePresence)

5. NPC turns (simplified AI for this phase):
   - When currentTurn is NPC_*, use setTimeout to simulate "thinking" (1-2s)
   - NPC raise: Select 2 random dice from npcPool
   - NPC see: Select minimum dice to meet total (greedy algorithm)
   - NPC escalate: If see would fail and higher level available, maybe escalate
   - NPC give: If cannot see and won't escalate

6. data-testid="conflict-view", data-testid="conflict-stakes"

**index.ts:**
Export all components from barrel file.
  </action>
  <verify>`npx tsc --noEmit` passes. Test by adding temporary START_CONFLICT dispatch in GameView or CycleView to trigger conflict.</verify>
  <done>ConflictView orchestrates full conflict flow from ACTIVE through RESOLVED with NPC AI turns.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All components compile
2. Temporarily trigger conflict from GameView/CycleView
3. Complete a simple conflict:
   - Player raises with 2 dice
   - NPC sees
   - Player raises again
   - NPC gives or player gives
4. Verify escalation confirmation appears with monologue
5. Verify turn history updates after each action
</verification>

<success_criteria>
- Player can complete raise/see bidding loop
- Escalation requires confirmation with internal monologue
- NPC responds with basic AI (raise/see/give)
- Turn history shows all actions
- Visual atmosphere changes with escalation level
</success_criteria>

<output>
After completion, create `.planning/phases/03-conflict-system/03-02-SUMMARY.md`
</output>
