---
phase: 03-conflict-system
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/Conflict/FalloutReveal.tsx
  - src/components/Conflict/ConflictResolution.tsx
  - src/utils/fallout.ts
  - src/types/game.ts
  - src/hooks/useGameState.tsx
autonomous: true

must_haves:
  truths:
    - "Fallout dice are rolled and revealed only at conflict end"
    - "Fallout severity maps to DitV thresholds (7/11/15/19/20+)"
    - "Fallout affects game state (condition penalty)"
    - "Player sees dramatic reveal of accumulated fallout"
  artifacts:
    - path: "src/components/Conflict/FalloutReveal.tsx"
      provides: "Animated fallout dice reveal"
      exports: ["FalloutReveal"]
    - path: "src/components/Conflict/ConflictResolution.tsx"
      provides: "Resolution screen with outcome and fallout"
      exports: ["ConflictResolution"]
  key_links:
    - from: "src/components/Conflict/ConflictResolution.tsx"
      to: "src/utils/fallout.ts"
      via: "imports calculateFallout"
      pattern: "import.*calculateFallout.*from.*utils/fallout"
    - from: "src/hooks/useGameState.tsx"
      to: "src/types/game.ts"
      via: "uses new APPLY_FALLOUT action"
      pattern: "APPLY_FALLOUT"
---

<objective>
Build fallout revelation UI and integrate fallout application into game state.

Purpose: Create the dramatic fallout reveal that makes escalation feel consequential, and apply fallout to character condition.
Output: FalloutReveal animation, ConflictResolution screen, and game state integration for fallout effects.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-conflict-system/03-CONTEXT.md
@.planning/phases/03-conflict-system/03-RESEARCH.md
@.planning/phases/03-conflict-system/03-01-SUMMARY.md

# Existing state patterns
@src/hooks/useGameState.tsx
@src/types/game.ts
@src/utils/dice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: FalloutReveal animated component</name>
  <files>src/components/Conflict/FalloutReveal.tsx</files>
  <action>
Create dramatic dice reveal component for fallout:

1. Props: `{ falloutDice: FalloutDice[], onComplete: (result: FalloutResult) => void }`

2. Reveal sequence (Framer Motion orchestration):

   a. **Phase 1 - Gathering** (1s):
      - "The cost of violence..." text fades in
      - Accumulated fallout dice appear, grouped by escalation level
      - Each group labeled: "From physical confrontation...", "From the fight...", etc.

   b. **Phase 2 - Rolling** (1.5s):
      - Dice animate rolling (rotate + slight movement)
      - Values revealed one by one with slight delay (stagger)
      - Sound would go here (noted for future)

   c. **Phase 3 - Calculation** (1s):
      - All dice values visible
      - Top 2 values highlight/grow
      - Sum displayed: "Highest: X + Y = Z"

   d. **Phase 4 - Verdict** (auto):
      - Severity revealed with appropriate gravity:
        - NONE: "You escaped unscathed" (relief)
        - MINOR: "A scratch, nothing more" (minor concern)
        - SERIOUS: "This will leave a mark" (worry)
        - DEADLY: "Your life hangs by a thread" (alarm)
        - DEATH: "The King of Life calls you home" (finality)
      - Call onComplete with FalloutResult

3. Framer Motion variants for each phase:
   - Use AnimatePresence for entering/exiting elements
   - Stagger children for dice reveal
   - Scale/opacity for emphasis

4. data-testid="fallout-reveal", data-testid="fallout-severity-{severity}"
  </action>
  <verify>`npx tsc --noEmit` passes. Component renders and completes sequence with mock FalloutDice.</verify>
  <done>FalloutReveal shows dramatic multi-phase reveal of accumulated fallout dice and calculated severity.</done>
</task>

<task type="auto">
  <name>Task 2: ConflictResolution screen and game state integration</name>
  <files>src/components/Conflict/ConflictResolution.tsx, src/types/game.ts, src/hooks/useGameState.tsx</files>
  <action>
**ConflictResolution.tsx:**

Create resolution screen combining outcome and fallout:

1. Props: `{ outcome: ConflictOutcome, stakes: string, npcName: string, falloutDice: FalloutDice[], witnesses: string[], onDismiss: () => void }`

2. Sequence:
   a. Stakes outcome first: "You [won/lost]: [stakes text]"
   b. FalloutReveal component for dice reveal
   c. After reveal: relationship impact if violent
      - "Brother [NPC] will remember this violence."
      - Show conflict history marker preview
   d. Continue button (only enabled after fallout reveal completes)

3. Layout:
   - Centered modal overlay (full screen, dark background)
   - Stakes outcome prominent at top
   - Fallout reveal in center
   - Relationship impact below
   - Continue button at bottom

4. data-testid="conflict-resolution", data-testid="resolution-outcome"

**src/types/game.ts updates:**

Add to GameState:
```typescript
characterCondition: number;  // 0-100, affects dice pool
```

Add to GameAction union:
```typescript
| { type: 'APPLY_FALLOUT'; severity: FalloutSeverity }
| { type: 'START_CONFLICT'; npcId: string; stakes: string }
| { type: 'END_CONFLICT' }
```

Import FalloutSeverity from conflict.ts.

**src/hooks/useGameState.tsx updates:**

1. Add `characterCondition: 100` to initialState

2. Add reducer cases:
   - **APPLY_FALLOUT**: Reduce characterCondition based on severity:
     - NONE: no change
     - MINOR: -10
     - SERIOUS: -30
     - DEADLY: -50
     - DEATH: set to 0 (game over state - handle separately)

   - **START_CONFLICT**: Set flag or transition that ConflictView reads

   - **END_CONFLICT**: Clear conflict-related state

3. Update generateDicePool call to use characterCondition instead of hardcoded 100
  </action>
  <verify>`npx tsc --noEmit` passes. Dispatch APPLY_FALLOUT with SERIOUS, verify condition reduces by 30.</verify>
  <done>ConflictResolution shows stakes outcome + fallout reveal + relationship impact. Game state tracks condition and applies fallout penalties.</done>
</task>

<task type="auto">
  <name>Task 3: Update ConflictView to use resolution components</name>
  <files>src/components/Conflict/ConflictView.tsx, src/components/Conflict/index.ts</files>
  <action>
Update ConflictView to integrate resolution flow:

1. When conflict phase becomes RESOLVED:
   - Render ConflictResolution instead of simple message
   - Pass accumulated falloutDice, outcome, stakes, witnesses

2. ConflictResolution onDismiss handler:
   - Dispatch APPLY_FALLOUT with calculated severity
   - Dispatch END_CONFLICT to game state
   - Reset local conflict state to INACTIVE

3. Wire up START_CONFLICT from game state:
   - ConflictView checks for pending conflict in game state
   - If game state has activeConflict data, initialize local conflict reducer
   - This allows conflicts to be triggered from action cards, NPC interactions, etc.

4. Add conflict trigger mechanism (temporary for testing):
   - In CycleView or GameView, add a temporary "Start Test Conflict" button
   - Dispatches START_CONFLICT with mock NPC and stakes
   - Button only visible in development mode

5. Update barrel export to include new components.

6. Verify full flow:
   - START_CONFLICT triggered
   - Bidding proceeds (raise/see)
   - One side gives
   - ConflictResolution shows outcome + fallout reveal
   - On dismiss, condition updated, conflict cleared
  </action>
  <verify>Complete full conflict flow from start to dismiss. Verify characterCondition in game state decreases after SERIOUS+ fallout.</verify>
  <done>ConflictView integrates resolution flow with fallout reveal and game state updates.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All files compile
2. Trigger test conflict
3. Play through to resolution
4. Verify fallout reveal animation sequence
5. Verify characterCondition decreases appropriately
6. Next cycle should have fewer dice if condition dropped
</verification>

<success_criteria>
- Fallout reveal shows dramatic multi-phase animation
- Severity calculated correctly from accumulated dice
- Game state condition decreases based on fallout severity
- Reduced condition affects next cycle's dice pool
- Full conflict flow works start to finish
</success_criteria>

<output>
After completion, create `.planning/phases/03-conflict-system/03-03-SUMMARY.md`
</output>
