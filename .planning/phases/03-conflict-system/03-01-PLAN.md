---
phase: 03-conflict-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/conflict.ts
  - src/reducers/conflictReducer.ts
  - src/utils/fallout.ts
  - src/hooks/useConflictAtmosphere.ts
autonomous: true

must_haves:
  truths:
    - "Conflict state correctly tracks escalation levels for both player and NPC"
    - "State machine enforces valid turn order (raise -> see -> raise)"
    - "Escalation dice are added when player escalates to higher level"
  artifacts:
    - path: "src/types/conflict.ts"
      provides: "ConflictState discriminated union, EscalationLevel type"
      exports: ["ConflictState", "EscalationLevel", "ConflictAction", "FalloutDice"]
    - path: "src/reducers/conflictReducer.ts"
      provides: "State machine reducer with phase guards"
      exports: ["conflictReducer", "initialConflictState"]
    - path: "src/utils/fallout.ts"
      provides: "Fallout calculation from accumulated dice"
      exports: ["calculateFallout", "generateFalloutDice"]
    - path: "src/hooks/useConflictAtmosphere.ts"
      provides: "CSS variable management for escalation theming"
      exports: ["useConflictAtmosphere"]
  key_links:
    - from: "src/reducers/conflictReducer.ts"
      to: "src/types/conflict.ts"
      via: "imports ConflictState, ConflictAction"
      pattern: "import.*from.*types/conflict"
    - from: "src/reducers/conflictReducer.ts"
      to: "src/utils/fallout.ts"
      via: "imports fallout utilities"
      pattern: "import.*from.*utils/fallout"
---

<objective>
Create the conflict system foundation: types, state machine reducer, fallout utilities, and escalation theming.

Purpose: Establish the type-safe foundation for DitV conflict mechanics with discriminated unions preventing invalid states.
Output: Conflict types, reducer with turn validation, fallout calculation, CSS variable theming hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-conflict-system/03-CONTEXT.md
@.planning/phases/03-conflict-system/03-RESEARCH.md

# Existing patterns to follow
@src/types/game.ts
@src/hooks/useGameState.tsx
@src/utils/dice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Conflict types and state discriminated union</name>
  <files>src/types/conflict.ts</files>
  <action>
Create conflict type definitions using discriminated unions:

1. **EscalationLevel** type: `'JUST_TALKING' | 'PHYSICAL' | 'FIGHTING' | 'GUNPLAY'`

2. **ConflictState** discriminated union with three phases:
   - `{ phase: 'INACTIVE' }` - No active conflict
   - `{ phase: 'ACTIVE', ... }` - Contains: npcId, stakes, playerPool (Die[]), npcPool (Die[]), playerEscalation, npcEscalation, turnHistory (ConflictTurn[]), currentTurn ('PLAYER_RAISE' | 'NPC_RAISE' | 'PLAYER_SEE' | 'NPC_SEE'), currentRaise ({ dice: Die[], total: number } | null), falloutDice (FalloutDice[])
   - `{ phase: 'RESOLVED', ... }` - Contains: outcome ('PLAYER_WON' | 'PLAYER_GAVE' | 'NPC_GAVE'), fallout (FalloutResult), witnesses (string[])

3. **ConflictTurn** interface: id, actor ('PLAYER' | 'NPC'), action ('RAISE' | 'SEE' | 'GIVE' | 'ESCALATE'), dice (Die[]), description (string)

4. **ConflictAction** type for reducer dispatch (START_CONFLICT, PLAYER_RAISE, PLAYER_SEE, PLAYER_GIVE, PLAYER_ESCALATE, NPC_RAISE, NPC_SEE, NPC_GIVE, NPC_ESCALATE, RESOLVE_CONFLICT)

5. **FalloutDice** and **FalloutResult** interfaces per RESEARCH.md

6. **ESCALATION_DICE** constant mapping level to { count, type }

Import Die and DieType from @/types/game.
  </action>
  <verify>`npx tsc --noEmit` passes without errors on conflict.ts</verify>
  <done>All conflict types defined with discriminated union pattern, no invalid state combinations possible</done>
</task>

<task type="auto">
  <name>Task 2: Conflict reducer with turn validation</name>
  <files>src/reducers/conflictReducer.ts</files>
  <action>
Create conflict state machine reducer following useGameState.tsx patterns:

1. **initialConflictState**: `{ phase: 'INACTIVE' }`

2. **conflictReducer** function handling all ConflictActions with phase guards:

   - **START_CONFLICT**: Only from INACTIVE. Sets up pools, stakes, npcId, initial escalation (JUST_TALKING), currentTurn: 'PLAYER_RAISE'

   - **PLAYER_RAISE**: Phase guard (ACTIVE only), turn guard (PLAYER_RAISE only). Validate exactly 2 dice from playerPool. Create currentRaise with dice and total. Remove dice from pool. Set currentTurn: 'NPC_SEE'. Add to turnHistory.

   - **PLAYER_SEE**: Phase guard, turn guard (PLAYER_SEE). Validate dice total >= currentRaise.total. Record turn type based on dice count: 1 = "Reverse the Blow", 2 = "Block/Dodge", 3+ = "Take the Blow". If 3+ dice, call generateFalloutDice and add to falloutDice array. Clear currentRaise. Set currentTurn: 'PLAYER_RAISE'. Remove dice from pool.

   - **PLAYER_GIVE**: Phase guard. Immediately resolve with outcome: 'PLAYER_GAVE'.

   - **PLAYER_ESCALATE**: Phase guard. Validate newLevel > current playerEscalation. Generate new dice via ESCALATION_DICE. Add to playerPool. Update playerEscalation. Add to turnHistory with monologue.

   - **NPC_RAISE/SEE/GIVE/ESCALATE**: Mirror player actions for NPC turns. NPC actions triggered by game logic (AI), not UI.

   - **RESOLVE_CONFLICT**: Calculate final fallout. Set phase: 'RESOLVED' with outcome, fallout, witnesses.

All invalid actions return state unchanged (silent fail pattern from Phase 2).
  </action>
  <verify>`npx tsc --noEmit` passes. Create a test file that dispatches actions and verifies state transitions.</verify>
  <done>Reducer enforces valid turn order, raises require exactly 2 dice, sees must meet or exceed raise total</done>
</task>

<task type="auto">
  <name>Task 3: Fallout utilities and escalation theming hook</name>
  <files>src/utils/fallout.ts, src/hooks/useConflictAtmosphere.ts</files>
  <action>
**src/utils/fallout.ts:**

1. **generateFalloutDice(raiseDice: Die[], escalationLevel: EscalationLevel): FalloutDice**
   - Creates FalloutDice with the raise dice and current escalation level
   - Used when player "Takes the Blow" (sees with 3+ dice)

2. **calculateFallout(accumulated: FalloutDice[]): FalloutResult**
   - Roll all accumulated dice
   - Sort values descending, sum top 2
   - Determine severity: <=7 NONE, <=11 MINOR, <=15 SERIOUS, <=19 DEADLY, 20+ DEATH
   - Determine falloutType from highest escalation level
   - Return { severity, falloutType, total, diceRolled }

3. **ESCALATION_ORDER** constant: { JUST_TALKING: 0, PHYSICAL: 1, FIGHTING: 2, GUNPLAY: 3 }

**src/hooks/useConflictAtmosphere.ts:**

1. **ESCALATION_COLORS** constant mapping level index to { bg, accent }:
   - 0 (JUST_TALKING): subtle blue-gray (calm conversation)
   - 1 (PHYSICAL): warm amber tint (tension rising)
   - 2 (FIGHTING): deep red tint (violence)
   - 3 (GUNPLAY): dark crimson (deadly)

2. **useConflictAtmosphere(escalationLevel: EscalationLevel | null)** hook:
   - If null, reset CSS variables to defaults
   - Set `--conflict-bg` and `--conflict-accent` on document.body
   - Use useEffect with cleanup to reset on unmount

Add CSS transition property to index.css or App.tsx for smooth color transitions:
`body { transition: background-color 0.5s ease; }`
  </action>
  <verify>`npx tsc --noEmit` passes. Manually test atmosphere hook by calling with different levels and inspecting document.body CSS variables.</verify>
  <done>Fallout calculates severity from accumulated dice, theming hook sets CSS variables for escalation atmosphere</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` - All files compile without type errors
2. Create temporary test in conflictReducer.ts that simulates a turn sequence:
   - START_CONFLICT -> state.phase === 'ACTIVE'
   - PLAYER_RAISE with 2 dice -> currentRaise has total, playerPool reduced
   - Invalid PLAYER_RAISE (wrong turn) -> state unchanged
3. FalloutResult severity matches DitV rules for sample dice totals
</verification>

<success_criteria>
- ConflictState discriminated union prevents invalid state combinations
- Reducer validates raise (2 dice) and see (>= raise total) requirements
- Fallout severity calculated correctly per DitV rules
- CSS variables update when escalation level changes
</success_criteria>

<output>
After completion, create `.planning/phases/03-conflict-system/03-01-SUMMARY.md`
</output>
